
* [[www.dotemacs.de][EMACA 网站]]    
* 悲催的事情
  DEADLINE: <2011-08-22 Mon>
  [] 今天查了四级成绩 挂了

*  for the sake of code readability :)
   为了代码可读性行
   [] One possible way to deal with being unfamiliar with something is to bec      ome familiar with it.
一种可能的处理不熟悉事物的方法就是去熟悉它。

* 读小工到专家的笺言
** TODO 测试代码(早测试， 常测试， 自动测试) 
   1. [] 单元测试
      - [] 各个模块能工作 没有错误
   2. [] 集成测试
      - [] 
   3. [] 验证和校验 
      - [] 程序可以运行的情况下，试问是否为客户的需要
   4. [] 资源耗尽及恢复
      - [] 内存空间
      - [] 磁盘空间
      - [] CPU带宽
      - [] 挂钟时间
      - [] 磁盘时间
      - [] 网络带宽
      - [] 调色板
      - [] 视频分辨率
      - []
   5. [] 性能测试
      - [] 性能测试，压力测试或负载测试可能会是项目的一个重要方面
        问问自己，软件是否能满足显示世界的条件下的性能需求--预期的用户数，连接数，或每秒的事务数， 它可以伸缩码？
        对于有些应用，可能需要专门的测试硬件或软件模拟现实情况下的负载
   6. [] 可用性测试
      - [] 换位思考 
   7. ...
      
* c++项目的敏捷实践
** C++语言
   [] C++是一门适合大型系统开发的语言
   [] 嵌入式系统
   [] 实时系统
   [] 高性能计算
   [] 系统编程
   [] 游戏
*** C++和敏捷
    敏捷开发实践与语言无关
    . 挑战主要来自于
    - 社区文化
    - 技术细节

****  1. [] 社区文化
     . 社区文化或许是最大的挑战
     - 保守
     - 对于变化的恐惧
     - 错误的假设
     - 流程
       . 瀑布式流程
       . 无流程

       一些常见态度
       . "聪明"受到推崇
     - 滥用宏
     - 滥用模板
     - 不必要的微观优化
       . BUFD
       . 测试是别人的事
     - Debug是解决问题的主要实践
       . 维护不包括重构
     - 一部分原因是语言自身的特点

       可能的改变
       . 测试驱动开发
       . 固定短周期的跌代
       . 每日构建/持续集成
       . 重构
       . 松耦合设计

****      测试驱动开发

       单元测试
       . 为了做好单元测试, 你需要
     - 一个合适的单元测试框架
     - 一个合适的mock框架
     - 一个合适的IDE/编辑器
     - 定义你的单元测试管理策略

       单元测试框架
       . CppUnit
       . CppUnitLite
       . Boost.Test
       . CxxTest

       Mock框架
       . mockpp (mockpp.sourceforge.net)
       -revised-mockpp (code.google.com/p/revised-mockpp)
       . mockcpp

       IDE
       . Eclipse CDT
       . SlickEdit 2008
       . Xrefactory C++

*****      单元测试构建策略
       . 规划你的目录结构以便单元测试用例的查找
       + project
       + include
       + #+BEGIN_SRC 
         
#+END_SRC
         
       + subsystem0
       + subsystem1
       + subsystem2
       + test
       + ft
       + ut
       + system0
       + class0
       + class1
       + system1
       + class3
       + system2
         . 创建一个单元测试套件应该尽可能的简单
         - IDE的支持
         - 选择一个使用简单的单元测试框架
         - 编写一个脚本
           . 一个脚本可以构建所有的单元测试
           . 可以独立运行单个测试
           . 可以独立运行单个测试套件
           . 能够统计所有的单元测试成功率
           . 能够将单元测试运行结果汇报给持续集成工具
           
****           构建速度
           . 良好的依赖管理
         - 物理依赖
           . 单一职责的头文件
           . 除非真正必要，否则不要在头文件中定义inline函数
           . 使用前导声明，而不是直接包含相关头文件
           . 把尽量多的东西放到源文件而不是头文件
           . 经常清理不必要的头文件包含
         - 逻辑依赖
           . 优先考虑委托而不是继承
           . 面向接口的设计
           . 依赖注入
           
           . 良好的构建策略
         - 分粒度的构建策略
         - 将所依赖的相对稳定的源文件的目标文件放入Repository
         - 考虑网络流量对于构建速度的影响
         - 预编译头文件
         - 联合编译
         - 增量式编译
         - 分布式编译
           
****           分布式编译工具
           distcc/ccache
           
****           增量式编译
           . 头文件依赖的自动管理
         - 编译器选项 + GNU make
         - automake
           
****          语言复杂性
           . C++是一个多范型的编程语言
           . 陷井太多, 容易误用
           . 全面掌握C++需要投入更多的精力
           
****           经验与技能
           . 经验和技能对于团队的成功至关重要
         - 语言
         - 工具
         - 实践
           . 经验缺乏导致C++项目的"偶发复杂度"非常高
           
****          结对编程
           
           共享责任/代码集体所有权
           
           持续集成
           . C++项目平台相关性
         - 要求必须在多种平台搭建持续集成环境
         - 嵌入式真实环境
         - 分离环境无关, 可在非产品环境中运行的测试. 如平台无关的单元测试, 代码质量检查
         - 支持平台匹配的CI工具
           
           . 大型C++项目的集时间
         - 一次集成和验证或许需要超过一天的时间
         - 重构测试用例
         - 优化构建策略
         - 并行运行不同的测试
           
           . 大量现存的工具没有考虑持续集成的需要
         - 基于CUI的人机交互
         - 无法获知工具执行的状态
           
           . 选取更合适的工具或完善自有工具
           
           持续集成工具
           . CruiseControl
           . LuntBuild
           . ThougthWorks Cruise
           
****           遗留系统
           . 糟糕的依赖管理
         - 超大的文件
         - 过长的函数
         - God Object
         - 过多的依赖具体实现
         - 到处存在的Singleton
         - 滥用继承
           
           . 错误的假设
         - 多重继承的偏见
         - 虚函数的偏见
         - 匈牙利命名法
         - 不合理的惯用用法

           . 过高的复杂度
         - 过度设计
         - 对于语言的不完善掌握所引入的不必要的复杂度
         - "聪明"所引入的复杂度
         - 大量的重复代码
         - 糟糕的抽象
         - 没有人能够了解整个系统
           
           . 缺少自动化测试用例
         - 不可测试的设计
         - 对于变化的恐惧
           
           遗留系统 - 解决方案
           . 忍受
           . 重新设计并实现
           . <<修改代码的艺术>>

