#+TAGS: EASY(e) COMM(c) OFFICE(o) READ(r) URGENT(u) FUTURE(f) WAIT(w) MEMO(m) 

* 计算机
** linux
** MS
** 编程
*** c++
   1. [] 建议：用于公共代码的私有实例函数
      1. [] 一般愿望是避免在多个地方编写同样的代码。
      2. [] display操作预期会随着类的演变而变的更复杂。当所涉及的动作变得更复杂时，只在一处而不是两处编写这些动作有更显著的意义
      3. [] 很可能我们会希望在开发时给do_display增加调试信息，这些调试信息将会在代码的最终成品中去掉。如果只需改变一个do_display的定义来增加或删除调试代码，这样做更容易
      4. [] 这个额外的函数调用不需要涉及任何开销，我们是do_display成为内联函的，所以调用do_display与将代码直接放入display操作的运行时的性能应该是相同的
   2. [] 实际上，设计良好的c++程序经常具有许多像do_display这样的小函数，他们被调用来完成一些其他函数的“实际”工作
   3.
     [1] 类需要析构函数吗？
   + 不是所有的的构造函数都需要析构函数,例如，表示复数的类即使有构造函数也可能不需要析构函数。如果深入考虑一个类需要做些什么，那么类是否需要析构函数的问题就十分明显了。应该问一问该类是否分配了资源，而这些资源又不会被成员函数自动释放，这个就足够了.特别是那些构造函数里包含了new 表达式的函数，通常需要在析构函数里面加入delete表达式，所以需要一个析构函数
   [2] 先释放旧值，在赋值
   + String& String::operator=(const String& str)
     {
       if(&s != this)
       {
         delete [] data;
         data = new char[strlen(s.data)+1];
         strcpy(data, s.data);
       }
       return *this;
     }
**** example
     
#+BEGIN_EXAMPLE
class Screen {
  public:
  // interface member functions
  // display overloaded on whether the object is const or not
  Screen& display(std::ostream &os) 
    { do_display(os); return *this; }
  const Screen& display(std::ostream &os) 
    { do_display(os); return *this; }
  privated:
    // single function to do the work of displaying a Screen,
    // will be called by the display operations
    inline void do_display(std::ostream &os) cosnt
        { os << contents;}
    mutiable size_t access_ctr; // may change in a const member
    // other data members as before
};

void Screen::do_display(std::ostream &os) cosnt {
  ++access_ctr; // keep count of calls to any members functions
  os << contents;
}

#+END_EXAMPLE


**** 1、什么是static?
       static 是C++中很常用的修饰符，它被用来控制变量的存储方式和可见性。

     2、为什么要引入static?
       函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，大家知道，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 最容易想到的方法是定义一个全局的变量，但定义为一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅受此函数控制）。

    3、什么时候用static?
       需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见。

    4、static的内部机制：
       静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。
       这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；三是应用程序的main（）函数前的全局数据声明和定义处。
      静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的“尺寸和规格”，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。
      static被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态
数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。

    5、static的优势：
       可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。

    6、引用静态数据成员时，采用如下格式：
         <类名>::<静态成员名>
    如果静态数据成员的访问权限允许的话(即public的成员)，可在程序中，按上述格式
来引用静态数据成员。

    7、注意事项：
      (1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致
了它仅能访问类的静态数据和静态成员函数。
      (2)不能将静态成员函数定义为虚函数。
      (3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊
，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。

      (4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就
产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W
indow系统结合，同时也成功的应用于线程函数身上。
      (5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问
时间，节省了子类的内存空间。
      (6)静态数据成员在<定义或说明>时前面加关键字static。
      (7)静态数据成员是静态存储的，所以必须对它进行初始化。
      (8)静态成员初始化与一般数据成员初始化不同:
      初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；
      初始化时不加该成员的访问权限控制符private，public等；
           初始化时使用作用域运算符来标明它所属类；
           所以我们得出静态数据成员初始化的格式：
         <数据类型><类名>::<静态数据成员名>=<值>
      (9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。 

*** ruby
*** python                                                             :READ:
    






